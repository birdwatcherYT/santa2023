
- 逆の操作を記録する done
- wildcard
    - スコア評価時に考慮する
- ゴールからたどると良い場合
    - ワイルドカードあるからだめか

## 小さい問題
- 全探索
- number puzzleっぽく探索する
- 現状: スコアの小さいものから探索するようになっているため、最短とは限らない
    - ハッシュのシード変えるだけでも変わるかも？
- case 30でメモリ足りない
    - 打ち切り done
    - 訪問済みを削除
    - stateを保存せず毎回シミュレートする
    - 候補生成をランダム化して絞る
    - 悪化しすぎる候補は追加しない
    - 長さ制限をいれた探索
- 並列化

## 大きい問題
- 初期解貪欲
    - なるべく状態が近くなるように
    - sample_submissionを初期値に
- 焼き鈍す
    - 近傍
        - action削除
        - action変更
        - action交換
        - action追加
        - 破壊再構築
    - スコア
        - ターゲットとの一致具合
        - actionの長さ

系列の区間を繋ぐ操作を生成する
    ランダム性のある貪欲
    前処理で同じ状態が2度出てきたら圧縮する

IDA*
https://qiita.com/guicho271828/items/b3e885c5bde5bf7183c2
https://qiita.com/persimmon-persimmon/items/48bf1b021c349d338f0f

ゴールから展開した地点との差を評価関数にする
2ステップを1操作にする
性質を観察する
双方向IDA

並行な操作には順序をつける
3/3/3
3回転=-1回転



- 互いに独立な操作に順序をつける done
- 複数操作をコスト付きでまとめる
    ループ
- ~~mistakeを変更箇所の数で割る~~

共通のゴールを持った問題たちをまとめて解く

双方向IDA*
frontierをいくつか保持する


g(start,x)+h(x,goal)
g(goal,y)+h(y,start)
- x: frontier from start
- y: frontier from goal

g(start,x)+h(x,y)+g(y,goal)
- x: frontier from start
- y: frontier from goal


<!-- hをfrontierとのminにする -->
双方向IDA*を再帰で書く
    スタックをスカラーで持つ
g(start,x)+h(x,y)+g(y,goal)を試す
DFSの探索順序を評価値順にする
評価関数を回帰する
    pythonでNNで推論できるか確認する
    NNをC++で書く
ソルバーに投げてみる


部分的に揃える

ゴールから制約付きでランダムに動かして、パターンを記録する(これをhとしてつかう)

<!-- h := 各点を揃えるために必要な回数の和
    事前計算可能

                  A
A A A A A A A A A B B B B B B B B B C C C C C C C C C D D D D D D D D D E E E E E E E E E F F F F F F F F F -->
メモリおさえる


ルービックキューブ専用のアルゴリズム
    https://qiita.com/7y2n/items/a840e44dba77b1859352
    http://kociemba.org/cube.htm
    https://www.kaggle.com/code/wrrosa/santa-2023-kociemba-s-two-phase-algo-1-116-550


輪っか専用のアルゴリズム

<!-- ゴールからとスタートから順にランダムに伸ばしてぶつかるか確認する -->
部分問題にする
g(start,x)+h(x,y)+g(y,goal)
双方向時は上限を半分にする
    解がみつからないのでバグかも → wildcardのケース

<!-- 並列処理 -->
<!-- 近傍点がwildcard考慮してゴールかどうか -->

近傍点をランダムウォークにする？
複数操作をまとめる


キューブ以外も特化したソルバー
    wreathは作りやすそう
    回転させて2つの色が揃ったら
双方向探索で現在の解への合流、現在の解を利用
図形の固定

ヒューリスティック関数をdoubleにして、割る
ソルバーへのラベルマッピング
    → パリティが異なるのでだめ

順不同操作の置き換えによる削減

globeを解く

pqの方もdoubleにする
双方向pqを試す

200からの改善はメモリがもう少し必要

1. 各地点から長さ制限しつつランダムウォークで候補生成
2. 交点を結んで改善していればマージ

双方向ビームサーチ
    top K個に絞る

大きいグラフを削減するほうが効率的
グラフごとに区間サイズを変える



分枝限定法
緩和問題に落とす

探索中に未来の状態が現れるかどうか見る


- globeを解く
- 近い状態まで持って行ってから探索


隣同士が異なる色かどうかで評価関数を作る
    小さい順にアクセスする
    IDA*

操作をmapで高速化する
隣の色がおなじになるような操作を貪欲に伸ばしていき未来に登場するかどうか

小さい問題に分割する

cube操作を続きから始めればいい説
操作2つをまとめて探索
既存解とのマージ
    パス上→ng
    近傍はどうか？→ng
    末尾X個のY近傍をそれぞれ

<!-- ワイルドカードのゴールへ早く付く場合を考慮 -->

系列焼きなまし！？

どんどん追加してみる
    改善するなら追加
    改善しないなら最もマシなやつを適用
    ループだけしないようにする

<!-- K連続置換の実装 -->

1 2 3 4
5 6 7 8
9 A B C
D E F G


number ---R---> sol
normal ---R^-1---> P
    solver=R'

number ---R'---> temp ---X---> sol
number ----------R-----------> sol

X=R'^-1 R

normal -------R'^-1 R-------> normal だが、他の状態から始めれば違う可能性がある。

normal ------random------> scramble -------R^-1-------> P
number ----------solver-----------random-----------> sol
                =R*random^-1


normal ---R^-2---> P
    solver=R'^2


random pruning

状態での圧縮と操作としての圧縮

TODO
<!-- - 探索において、事前に複数操作をまとめるのは有効そう -->
   <!-- - Kステップごとに上位N個を残したビームサーチをする -->
   <!-- - 一致度の推移をプロットする -->
<!-- - K step置換を修正 -->
- nxnxnのレポジトリを見る
- さらなる圧縮を考える
    - 途中で何回も向きを変えるのは不要で最後に合わせればいい
        - 回転同一なものを検知する
        - 5x5x5のとき、上3つ回転させるなら、下2つのほうがいい

samegroup = { 0:-1, 1:1, 2:1, 3:1, 4:1, 5:1, 6:1, 7:1, 8:1, 9:1, 10:1, 11:1, 12:1, 13:1, 14:1, 15:1, 16:1, 17:1, 18:-1, }
↓
samegroup = { 0:-2, 18:-2, }

samegroup = { 0:1, 1:1, 2:0 }
samegroup = { 2:-1, } & { 0:1, 1:1, 2:1 }
TODO: 
    - 逆操作も可能にする
    - ベスト挿入箇所を探索する


ゼロを多くする
各点をゼロにしたとき、最も少ない回転数のものを使う

操作を焼く
    初期解
        現在の解
    近傍
        actionを追加(現状の解の長さが上限)
        actionを削除
        actionをswap
    スコア
        mistake数

    破壊再構築



15x15で7動かす、みたいな場合に対処する
cubeも、一旦回転して操作後元に戻したあとに、もう一度回転させて操作してもとに戻すとかはあるかもしれない。。。


合成操作の圧縮を考える
合成操作同士が平行なら入れ替える

交換できる合成操作を見つける

中心は向きまで揃える必要がない

<!-- よく使われている操作1つに着目してより短い操作に置き換える -->
<!-- まとまった操作が連続しているか確認する、回転数を確認する -->

同じ長さの別グループ表現に変えて圧縮する

十字を揃えに行って5x5に投げる


入れ替える魔法を見る
今は連続した可換操作しか交換圧縮を試みていないが、飛んだ場所で交換可能性も確認する

TODO
- 後処理
    - swap高速化

- cube
    - magic 5-2
    - パリティ解消helper
    - 3x3 cube solver
    - 焼き鈍す
    - step-kの汎用魔法をつくる

1 234 56789
1 56789 234

      se
1 234 56 789ABCDEFG
1 56 234 789ABCDEFG

      s       e
1 234 56789ABCD EFG
1 56789ABCD 234 EFG

i
0 12 345 EFG 56789ABCD 
0 12 34   FG 56789ABCD 
